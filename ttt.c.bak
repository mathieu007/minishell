#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

extern char** environ;
int		return_code;


char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*mem;
	size_t	s1_l;
	size_t	s2_l;

	s1_l = strlen(s1);
	s2_l = strlen(s2);
	mem = (char *)malloc(sizeof(char) * (s1_l + s2_l + 1));
	if (!mem)
		return (NULL);
	memcpy(mem, s1, s1_l);
	memcpy(&mem[s1_l], s2, s2_l);
	mem[s1_l + s2_l] = '\0';
	return (mem);
}

char	*ft_strjoinfree(char *s1, char *s2)
{
	char	*mem;
	size_t	s1_l;
	size_t	s2_l;

	s1_l = strlen(s1);
	s2_l = strlen(s2);
	mem = (char *)malloc(sizeof(char) * (s1_l + s2_l + 1));
	if (!mem)
		return (free(s1), NULL);
	memcpy(mem, s1, s1_l);
	memcpy(&mem[s1_l], s2, s2_l);
	mem[s1_l + s2_l] = '\0';
	return (free(s1), mem);
}

char	*ft_strjoinfree2(char *s1, char *s2)
{
	char	*mem;
	size_t	s1_l;
	size_t	s2_l;

	s1_l = strlen(s1);
	s2_l = strlen(s2);
	mem = (char *)malloc(sizeof(char) * (s1_l + s2_l + 1));
	if (!mem)
	{
		if (s1)
			free(s1);
		if (s2)
			free(s2);
		return (NULL);
	}
	memcpy(mem, s1, s1_l);
	memcpy(&mem[s1_l], s2, s2_l);
	mem[s1_l + s2_l] = '\0';
	if (s1)
		free(s1);
	if (s2)
		free(s2);
	return (mem);
}

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <string.h>


char *get_output(char *full_path, char *filename, char *arg1, int32_t fileno, int32_t discard) {
	int std_pipe[2];
	char *output = NULL;
	if (pipe(std_pipe) == -1) {
		perror("Failed to create pipe");
		exit(EXIT_FAILURE);
	}
	pid_t child_pid = fork();
	if (child_pid == -1) {
		perror("Failed to fork");
		exit(EXIT_FAILURE);
	} else if (child_pid == 0) {
		if (dup2(std_pipe[1], fileno) == -1) {
			perror("Failed to redirect stderr");
			exit(EXIT_FAILURE);
		}
		int dev_null_fd = open("/dev/null", O_WRONLY);
        if (dev_null_fd == -1) {
            perror("Failed to open /dev/null");
            exit(EXIT_FAILURE);
        }
        if (dup2(dev_null_fd, discard) == -1)
		{
            perror("Failed to redirect");
            exit(EXIT_FAILURE);
        }
        close(dev_null_fd);
		close(std_pipe[1]);
		execlp(full_path,filename, arg1, NULL);
		perror("Failed to execute command");
		exit(EXIT_FAILURE);
	} else {
		close(std_pipe[1]);
		int child_status;
		waitpid(child_pid, &child_status, 0);
		char buffer[256];
		ssize_t read_size;
		int len;
		len = 0;
		while ((read_size = read(std_pipe[0], buffer, sizeof(buffer))) > 0)
		{
			buffer[read_size] = '\0';
			output = realloc(output, len + read_size + 1);
			if (output == NULL)
			{
				perror("realloc failed");
				exit(EXIT_FAILURE);
			}
			strcpy(output + len, buffer);
			len += read_size;
		}
		close(std_pipe[0]);
		if (WIFEXITED(child_status))
			return_code = WEXITSTATUS(child_status);
		else if (WIFSIGNALED(child_status))
			return_code = WTERMSIG(child_status);
	}
	return output;
}

char *get_output2(char *full_path, char *filename, char *arg1, char *arg2, int32_t fileno, int32_t discard) {
	int std_pipe[2];
	char *output = NULL;
	if (pipe(std_pipe) == -1) {
		perror("Failed to create pipe");
		exit(EXIT_FAILURE);
	}
	pid_t child_pid = fork();
	if (child_pid == -1) {
		perror("Failed to fork");
		exit(EXIT_FAILURE);
	} else if (child_pid == 0) {
		if (dup2(std_pipe[1], fileno) == -1) {
			perror("Failed to redirect stderr");
			exit(EXIT_FAILURE);
		}
		int dev_null_fd = open("/dev/null", O_WRONLY);
        if (dev_null_fd == -1) {
            perror("Failed to open /dev/null");
            exit(EXIT_FAILURE);
        }
        if (dup2(dev_null_fd, discard) == -1)
		{
            perror("Failed to redirect");
            exit(EXIT_FAILURE);
        }
        close(dev_null_fd);
		close(std_pipe[1]);
		execlp(full_path,filename, arg1, arg2, NULL);
		perror("Failed to execute command");
		exit(EXIT_FAILURE);
	} else {
		close(std_pipe[1]);
		int child_status;
		waitpid(child_pid, &child_status, 0);
		char buffer[256];
		ssize_t read_size;
		int len;
		len = 0;
		while ((read_size = read(std_pipe[0], buffer, sizeof(buffer))) > 0)
		{
			buffer[read_size] = '\0';
			output = realloc(output, len + read_size + 1);
			if (output == NULL)
			{
				perror("realloc failed");
				exit(EXIT_FAILURE);
			}
			strcpy(output + len, buffer);
			len += read_size;
		}
		close(std_pipe[0]);
		if (WIFEXITED(child_status))
			return_code = WEXITSTATUS(child_status);
		else if (WIFSIGNALED(child_status))
			return_code = WTERMSIG(child_status);
	}
	return output;
}

int main(void) {
    char *name;
    char *full_name;
    int stderr_pipe[2];
    pid_t child_pid;
    int child_status;
    char buffer[256];
    ssize_t read_size;
    int exit_status;
    int signal_num;

    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        perror("getcwd() error");
        return 1;
    }
    name = "/bin/minishell";
    full_name = ft_strjoin(cwd, name);
	
	printf("fullname : %s\n", full_name);
	printf("minishell output :[%s] \n", get_output2(full_name, "./bin/minishell", "echo '123'", NULL, STDOUT_FILENO, STDERR_FILENO));
	printf("minishell error  :[%s] \n", get_output2(full_name, "./bin/minishell", "echo '123'", NULL, STDERR_FILENO, STDOUT_FILENO));
	
	printf("bash output :[%s] \n", get_output2("bash", "bash", "-c", "echo '123'", STDOUT_FILENO, STDERR_FILENO));
	printf("bash error  :[%s] \n", get_output2("bash", "bash", "-c","echo '123'", STDERR_FILENO, STDOUT_FILENO));
    return 0;
}

